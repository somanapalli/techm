
10 days - core java

    any programmers achievement 
	
	 -to develop the software/application 
	 
	 
software/application:

  collection of programs 
  
  every programmer must follow syntaxes 
  
  
  if programmer not follows syntaxes 
  what will happen?
  
     java compiler 
	 
it is the system defined java program 

purpose: to check the syntaxes of the program 

	 
why should we learn core java?

 what type of applications we have?


   -desktop / standalone application 

   -distributed application 

   
1.using core java knowledge, we can develop 
  desktop applications

2.we can learn advaned java.

3.we can get a chance to learn some highend tools

  like 
     hadoop 
	 salesforce
	 pega
	 tableu.. 
	 
	 






  
	 
	 
	 
	 
	 
	 
	 
	 
 command to compile the java program 

   javac <filename>.java

   javac Welcome.java

path:

path is the location, where all the java tools 
are available. 

C:\Program Files\Java\jdk-19\bin


   how to set the path:
   
   salesforce
  
  
  command to execute the java program
  
   java <classname>
   
   java Welcome
   
   
 what is java?


  java is object oriented programming langugage
  
  
    because it follows oops principles.
	
	 oops principels are given by -omg
	 
	 1.inheritance
	 2.polymorphism
	 3.abstraction 
	 4.encapsulation 
	 
	  
in java, to achieve the above 4 principles we do 
have two concepts are there.

  
 1.class
 2.object


class:
```````
  class is a collection of 
  
  -variables
  -methods
  
  





 



class Techm
{
   stname;
   stid;
   
   
   learn()
   {
   }
   observe()
   {
   }
   teaching()
   {
   }
   listening()
   {
   }
  
}


 every java program should start with by defining 
 the class .
 
 note:
 without defining the classs, there is no java 
 program.
 
 
 variable:
 ````````````
 variable is a name which we are giving to the 
 memory lcoation, 
 
 because of variables, we are able to improve 
 the readability of the code.
 
 purpose: to store the data.
 
 syntax:
    
	 <datatypename> <variablename> = <value>;
	 
	 
	 int stid = 100;
	 
	 
	 
 in java, we have 4 cateogires
 
 
 integer
 
    -byte
	-short
	-int
	-long
	
 
 character
 
    char
 
 
 float
 
    -float
	-double
	
 
 boolean 
 
    -boolean 
	
	
 
 integer category datatype 
  purpose: to store the numeric values
  
  
 every datatype has maintaining two things
 
 
 1.memory size
 2.range 
 
 byte - 1byte- 8bits
 short -2 bytes - 16 bits
 int - 4bytes
 long - 8bytes
 
formula to calculate the range of the datatype.

byte

  -2^n-1 to (2^n-1) -1
  
  -2^7 to 2^7 - 1
  -128 to 127
  
  byte b = 130;
  
 
 
 
 https://github.com/somanapalli/dhaapps
  
method:
```````
method is the place , where we are writing the logic to perform some operation based on the 
requirement.

syntax:

   <returntype> <methodname>()
   {
   
   }
  
  method definition = method heading + method body
  
  
  define the method display, which prints 
  welcome message.
  
    void display()
	{
	
	  System.out.println("welcome to techm");
	}
  
  void =returntype 
  meaning: not returning any value.
  
  
 define one method , which gives name of the student?

    String s = "Ram";
	
  
  String getStudentName()
  {
     return "ram";
  }
  
  note:
  return type and return value must be compatible
  or same with each other.
  otherwise we will get compile time error.
  
  
define one method which gives marks of the student?

  float getStudentMarks()
  {
  
    return 98.5f;
  }
  
define one method which gives salary of the employee?

       double getEmployeeSalary()
	   {
	   return 22000.78;
	   }


define one method which takes two integer parameters and returns their sum?

    
	 int getSum(int a, int b)
	 {
         return a+b;
	 }

define one method which takes firstname, lastname 
as paramters and returns their fullname?

            String getFullName(String first_Nname, String last_name)
			{
			return firstName+lastName;
			}

rules to declare the variables:
```````````````````````````````
rules to declare the variable name:
``````````````````````````````````````
1.variable name should always starts with alphabet 
  it should not start with numeric 

2.no special characters are allowed except $ and _(underscore)  

3.we are not allowed to use varaible names as java reserved words.

  
4.variable names are case sensitive.

5.blank spaces are not allowed while we are declaring the variables.

  String student_name = "Ram"


class is a collection of variables and methods 
into a single unit. that single unit is known 
as class. 

note:
inner method defintion is not possible in java
inner method invocation is possible in java.








object:
instance of class is known as object
instance:

allocating sufficient amout of memeory space 
for the instance properties which we are declaring inside
the class.

syntax:

 <classname> <objectname> = new <classname>();
 ex:
 
  Student obj = new Student();
  
  Student ->name of the class
  obj  -> name of the object
  = -> assignment operator
  new ->dynamic memory allocation operator
  Student() -> constructor 
  
  
  
example:
`````````

public class Student {

	//variables 
	int stid=100;
	String stname="Ram";
	//method definition 
	
	 void getStudentInfo()
	{
		System.out.println("student id is:" + stid);
		System.out.println("student name is : " + stname);
	
	}
	 
	 public static void main(String[] args) {
		
		 
		 Student obj = new Student();
		 
		 System.out.println(obj.stid);
		 System.out.println(obj.stname);
		 
		 //call the method
		 
		 obj.getStudentInfo();
		 
	}
	
}


instance vs static:
```````````````````
  instance area
  
  static area
  
  
  void m1()
  {
  //instance area
  }
  
  
  static void m2()
  {
  //static area
  }
  
  
  
  the area which belongs to non static /instance 
  method is known as instance area.
  
  the area which belongs to static method is known 
  as static area.
  
  
example on instance vs static?
``````````````````````````````

public class Student {

	//instance variables 
	int stid=100;
	String stname="Ram";
	static String collegeName="Aditya";
	//method definition 
	
	//instance method
	 void getStudentInfo()
	{
		 //instance area
		System.out.println("student id is:" + stid);
		System.out.println("student name is : " + stname);
		System.out.println("college name is: " + collegeName);
	
	}
	 
	 public static void main(String[] args) {
		
		 //static area
		 Student obj = new Student();
		 
		 System.out.println(obj.stid);
		 System.out.println(obj.stname);
		 System.out.println(Student.collegeName);
		 
		 //call the method
		 
		 obj.getStudentInfo();
		 
	}	
}



constructor:
````````````
constructor is a special member method which is used to initialize the object.


 int a;
 a=100;
 
 int a =100;
 
 initialization = declaration + assigning the value.
 
 constructor is used to initialize the object.
 
 
 rules:
 
 constructor must be similar to class name.
 
 constructor should not return anything even void 
 also.
 
 constructor should not be static
 constructor should not be inherited.
 
example without constructor:

public class Student {

	//variables declaration 
	int stid;
	String stname;
	
	public void setValues()
	{
		//assigning the values
		stid=100;
		stname="Naveen";
		
	}
	
	public void display()
	{
		System.out.println("student id is : " + stid);
		System.out.println("student name is : " +stname);
	}
	 
	
    public static void main(String[] args) {
		
    	
    	Student obj = new Student();
    	
    	obj.setValues();
    	obj.display();
    	
	}
	 
	
}


example with constructor:
`````````````````````````

public class Student {

	//variables declaration 
	int stid;
	String stname;
	
    //define the constructor
	Student()
	{
		stid=100;
		stname="priya";
	}
	
	public void display()
	{
		System.out.println("student id is : " + stid);
		System.out.println("student name is : " +stname);
	}
	 
	
    public static void main(String[] args) {
		
    	
    	Student obj = new Student();
    	
    	
    	obj.display();
    	
	}
	 
	
}

types of constructors:
``````````````````````
in java, we have two types of constructors are there
  
    1. default constructor
	
	      -system defined /compiler generated 
		   default construcotr 
		     -purpose: to initialize default values
		   
		  -user defined default constructor
		  
		     -purpose: to initialize our own values.
			 

example on user defined default constructor and system defined default constructor


public class Student {

	// variables declaration
	int stid;
	String stname;

	public void display() {
		System.out.println("student id is : " + stid);
		System.out.println("student name is : " + stname);
	}

	/*
	 * system define default constructor
	 * public Student() { stid=0; stname=null; }
	 */
	
	//user defined default constructor
	public Student()
	{
		stid=100;
		stname="Rama";
	}

	public static void main(String[] args) {

		Student obj = new Student();

		obj.display();

	}

}


2.parameterized constructor
	

 it is a constructor which takes parameters 
 
 
example on parameterized constructor:
``````````````````````````````````````

public class Student {

	// variables declaration
	int stid;
	String stname;
	
	//parameterized constructor
	public Student(int x, String y)
	{
		stid=x;
		stname=y;
	}

	public void display() {
		System.out.println("student id is : " + stid);
		System.out.println("student name is : " + stname);
	}

	public static void main(String[] args) {

		//create the object using parameterized constructor
		
		Student obj = new Student(100,"sravan");
		obj.display();

	}

}








  
  
example on both user defined and parameterized 
constructor:


public class Student {

	// variables declaration
	int stid;
	String stname;
	
	//parameterized constructor
	public Student(int x, String y)
	{
		stid=x;
		stname=y;
	}
	
	//user defined default constructor
	public Student()
	{
		stid=100;
		stname="ram";
	}

	public void display() {
		System.out.println("student id is : " + stid);
		System.out.println("student name is : " + stname);
	}

	public static void main(String[] args) {

		//create the object using parameterized constructor
		
		Student obj = new Student(100,"sravan");
		obj.display();

		//create the object using user defined default constructor
		Student obj1 = new Student();
		obj1.display();
		
	}

}

this keyword:
```````````````
it is a java reserved keyword
'this' is pointing current class object.

 advantages:
 ```````````
 1.to differntiate class level variables and 
 method level parametes when both are same.
 
example:
`````````

public class Demo {

	//class level variables
	int x,y;
	
	public void setValues(int x, int y)
	{
		//assigning local values to class level variables
		this.x=x;
		this.y=y;
	}
	
	
	public void display()
	{
		System.out.println(x + " " + y);
	}
	public static void main(String[] args) {

		
		Demo obj = new Demo();
		obj.setValues(100,200);
		obj.display();
		
	}

}



2.this() - call current class default constructor
  this(..) - call current class parameterized constructor 


whenever we have multiple construcotrs, to execute 
these multiple constructors we no need to create 
multiple objects 

just by creating single object, by using this syntax like this() , this(..) we are allowed to execute multiple constructors using single object .


constructor call must be the first statement 
inside a constructor 



example:
```````

public class Student {

	//parameterized constructor
	public Student(int x, String y)
	{
		
	System.out.println("iam parameterized constructor");
	}
	
	//user defined default constructor
	public Student()
	{
		//calling current class parameterized constructor
		this(100,"Ram");
	System.out.println("iam default constructor");
	
	}

	

	public static void main(String[] args) {

		//create the object using parameterized constructor
		
		Student obj = new Student();
	
	}

}

  
control statements/conditional statements
``````````````````````````````````````````
java compiler executes the code from top to bottom.


The statements in the code are executed according to the order
in which they appear.



However, java provides statements that can be used to control the 
flow of the java code. such statements are called control statements


java provides three types of control statements 


1.Decision making statements
2.loop statements
3.jump statements


1.Decision making statements:
`````````````````````````````

as the name suggests, decision making statements decide which statement
to execute and when.


Decision making statements evoluate boolean expression and 
control the progrma flow depending upon the result of the condition 
provided.

There are two types of decision making statemetns in java, i.e 
   -if 
   -switch
   
   
if statement:
``````````````
this staement is used to evoluate a boolean condition.

the condition of the if statement gives a boolean value either true 
or false.

in java, there are four types of if statements 

 1.simple if statement
 2.if-else statement
 3.if-else-if ladder
 4.nested if statement 
 
 

1.simple if statement:
``````````````````````
syntax:

 if(condition)
 {
   //statemetns
 }
 
example:
````````

public class Student {

	
	public static void main(String[] args) {
		
		int x=10,y=20;
		
		if(x+y>20) {
			System.out.println("x+y is greater than 20");
		}
		
	}
}

2.if-else statement:
````````````````````
a block is a concept of in between { and }

 if
 {
 
 }

if else staement is an extension of if statement, which uses 
another block of code. i.e catch block.

The else block is executed if the condition of the if block is 
evlouated as false.


syntax:
  
     if(condition){
	   //statement1;//executes when condition is true
	   }
	 else{
	   statement2 ;//executes when condition is false.
	 }

 
example:
`````````

public class Student {

	
	public static void main(String[] args) {
		
		int x=10,y=20;
		
		
		
		if(x+y<20) {
			System.out.println("x+y is less than 20");
		}
		else
		{
			System.out.println("x+y is greater than 20");
		}
	}
}

if-else-if ladder:
`````````````````````

it contains 

 1 if block
 
 multiple else if blocks 
 
 1 else block 
 
 syntax:
 
  if(condition1)
  {
    statement1;//executes when condition 1 is true
  }
  else if(condition2)
  {
    statement2;//executes when condition2 is true
  }
  else if(condition3)
  {
    statement3;//executes when conditio3 is true
  }
  ...
  else
  {
    statement4;//executes when all the condistions are false.
  }
  
example:
`````````

public class Student {

	
	public static void main(String[] args) {
		
		String city="Agra";
		
		if(city=="Chennaih") {
			System.out.println("city is chenniah");
		}
		else if(city=="Hyderabad")
		{
			System.out.println("city is Hyderabad");
		}
		else if(city=="pune")
		{
			System.out.println("city is pune");
		}
		else
		{
			System.out.println(city);
		}
			
	}
}


nested if statement:
```````````````````
in nested if statement, the if staetment can contain a if 


syntax:


  if(condition1)
  {
    staetment1;//executes when condition1 is true
	
	 if(condition2)
	 {
	    statement2;//executes when condition2 is true
	 }
	 else
	 {
	    statement3;//executes when condition2 is false.
		
	 }
  }
  
  

example:
`````````

public class Student {

	
	public static void main(String[] args) {
		
		int a=10,b=20;
		if(a==10)
		{
			if(b!=20)
			{
				System.out.println("dhaaps");
			}
			else
			{
				System.out.println("ramakrishna");
			}
			
		}
	}
}




switch statement:
````````````````

switch statement executes one statement from multiple conditions. 
it is like if-else-if ladder statement.


1.there can be one or n number of case values for a switch expression.

2.the case value must be of switch expression type only.
  the case value must be literal or constant.it doesn't allow 
  variables.
  
3.the case value must be unique, in case of duplicate value it will give you compile time error.


4.java switch expression type must be of byte,short,int,long(with its 
wrapper type),enums and string.

5.each case statement can have a break statement which is optional.

syntax:
```````
 switch(expression)
 {
 
   case value1:
   //code to be executed
   break;//optional
   
   case value2:
   //code to be executed
   break;//optional 
   
   ....
   
   default:
   //code to be executed if all case values are not matched
   
 
 }


}


 
example:
````````

public class Student {

	
	public static void main(String[] args) {
		
		int number=40;
		
		switch(number)
		{
		
		//case statements
		
		case 10:System.out.println("10");
		break;
		case 20:System.out.println("20");
		break;
		case 30:System.out.println("30");
		break;
		default:System.out.println("not in 10,20 or 30");
		}
	}
}


loop statements:
`````````````````
Loops in Java is a feature used to execute a particular part of the program repeatedly if a given condition evaluates to be true.


   -for loop
   -while loop 
   -do while loop
   
for loop:
`````````
purpose:

this for loop is used to iterate a part of the program several/multiple times.

when should you use for loop?

if the number of iteration is fixed, it is recommended to use
for loop.

 -simple for loop
 -nested for loop
 -for each or enhanced for loop
 -labelled for loop

 simple for loop:
 ````````````````
 we can initilize the variable,
 check the condition ,
 increment/decrement the value 
 
 it consitsts of four parts
 
 1.initialization -it is an optional condition 
 
 2.condition 
 
 3.increment/decrement
 
 4.statement
 
syntax:

 for(initialization;condition;increment/decrement)
 {
  //statement 
 }
 
example:
```````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
      int i=1;
       for(i=1;i<=10;i++)
       {
    	   System.out.println(i);
       }
	    
	}
}

//program to displaying first 10 numbers in reverse order?

example:
`````````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
      int i=10;
       for(;i>=1;i--)
       {
    	   System.out.println(i);
       }
	    
	}
}


display even numbers from 1 to 10 using for loop and if statement?

2

4

6

8

10

example:
``````````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
		
		  for(int i=1;i<=10;i++) { 
			  if(i%2==0)
			  {
				 System.out.println(i); 
			  }
		  
		  }
		 
	   // % operator is giving you reminder
	   
	   
	}
}

assignment:
```````````
display odd numbers from 1 to 10 using for loop and if statement?


example:
````````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
		
		  for(int i=1;i<=10;i++) { 
			  if(i%2!=0)
			  {
				 System.out.println(i); 
			  }
		  
		  }
		 
	   // % operator is giving you reminder
	   
	   
	}
}


nested for loop:
````````````````
defining for loop inside another for loop. 


if we have a for loop inside another for loop, it is known as 
nested for loop.

The inner for loop executes completely whenever outer for loop 
executes.

once control comes from outerfor loop to inner for loop, it executes inner for loop until the condition became false, once condition false 
again it goes back to outerfor loop then comes to inner loop like this 
flow is going on.



example:
````````
//program on nested for loop
public class Test2 {

	public static void main(String[] args) {

		// loop of i

		for (int i = 1; i <= 3; i++) {
			// loop of j
			for (int j = 1; j <= 3; j++) {
				System.out.println(i + " " + j);
			}
		}

        
	}
}

/*output:
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3*/



output:
````````
*
* *
* * *
* * * *
* * * * *

example:
`````````

public class Test3 {

	public static void main(String[] args) {
		
		//define the outer for loop
		
		//outer for loop
		for(int i=1;i<=5;i++)
		{
			//inner for loop
			
			for(int j=1;j<=i;j++)
			{
				System.out.print("*");
			}
			
			System.out.println();
			
		}
	}
}

output:
```````
*
* *
* * * 
* * * *
* * * * * 






output:
````````
* * * * * *
* * * * *
* * * *
* * * 
* * 
*
   do this program as an assignment?
   
   











for each loop or enhanced for loop:
````````````````````````````````````

this enhanced for loop introduced from java 1.5 version onwards.

purpose:
``````````
it provides an alternative approach to traverse the array or collection in java.


it is mainly used to traverse the array or collection elements.

how the values will be stored inside an array variable?
  
  based on the index 
  
  array index starts from 0th location .
  
  
 int a[]={100,200,300};
 
  sysout(a[0]);
  sysout(a[1]);
  
  
note:
if the array length is 'n' 
maximum index is 'n-1'
because array index starts from 0 th location

  

syntax of foreach loop:
````````````````````````
it consists of datatype with the varaible followed by a colon (:) , then array or collection varaible.

  for(datatype variable:actualvaraible)
  {
  
     //body of for each loop
  }


int a[]={10,20,30,40,50};


  for(int b:a)
  {
    System.out.println(b);
  }

example:
`````````
class Test4
{
	
	public static void main(String[] args) {
		
		int a[]= {10,20,30,40,50};
		
		System.out.println(a[0]);
		System.out.println(a[1]);
		System.out.println(a[2]);
		System.out.println(a[3]);
		System.out.println(a[4]);
		
		System.out.println("=======using for loop displaying array elements============");
		
		for(int i=0;i<a.length;i++)
		{
			System.out.println(a[i]);
		}
		
		System.out.println("======using for each loop displaying array elements===");
		
		for(int b:a)
		{
			System.out.println(b);
		}
		
	}
}


//using for each loop calculate total of array elements
  int a[] ={1,2,3,4};
  
answer:
```````

public class Test5 {
	
	public static void main(String[] args) {
		
		int a[]= {1,2,3,4};
		int sum=0;
		for(int b:a)
		{
			sum=sum+b;
		}
		
		System.out.println("sum of array elements is : " + sum);
	}

}

 
 

java labelled for loop:
```````````````````````
we can have a name of each java for loop.

To do so, we used label before the for loop.

it is useful while using the nested for loop as we can break/continue
specific for loop.

syntax:

  labelname:
  
   for(intialization;condition;increment/decrement)
   {
     //code to be executed
    }
	
example:
`````````
//program on nested for loop
public class Test2 {

	public static void main(String[] args) {

		// using label for outer for loop
	aa:
		for (int i = 1; i <= 3; i++) {
			// using label for inner forloop of j
			
	bb:
			for (int j = 1; j <= 3; j++) {
				
				if(i==2&&j==2) {
					break aa;
				}
				System.out.println(i + " " +j);
			}
		}

	}
}

/*output:
1 1
1 2
1 3
2 1
*/



  

java while loop:
`````````````````
the java while loop is used to iterate a part of the program 
repeatedly until the specified condition is true.

as soon as the condition becomes false, the loop automatically stops.

the while loop is considered as a repeating if statement. 
if the number of iternation is not fixed, it is recommended to use the  while loop.


syntax:
```````    
   //intialize the value;
    while(condition)
	{
	  //code to be executed;
	  increment/decrement ;
	}

write one java program displaying 1 to 10 numbers using while loop?

example:
````````

public class Test6 {
	
	public static void main(String[] args) {
		
		//initialization 
		int i=1;
		//while loop
		
		while(i<=10)
		{
			System.out.println(i);
			i++;
		}
	}

}

do this program to display the 1 to 10 numbers in reverse order?


public class Test6 {
	
	public static void main(String[] args) {
		
		//initialization 
		int i=10;
		//while loop
		
		while(i>=1)
		{
			System.out.println(i);
			i--;
		}
	}

}


do while loop:
``````````````
do while loop is used to iterate a part of the program repeatedly,until the specified condition is true.

if the number of iteration is not fixed and you must have to execute
the loop at least once, it is recommended to use a do-while loop.

do while loop is called an exit control loop.

java do while loop is executed at least once because condition is 
checked after loop body.


syntax:
```````
  do{
  
    //code to be executed/loop body
	//update staetment
  
  } while(condition);
  
  
example:
````````

public class Test7 {
	
	public static void main(String[] args) {
		
		int i=1;
		do {
			System.out.println(i);
			i++;
			
		} while (i>=10);
		
	}

}

for loop v/s while loop v/s do-while loop:
``````````````````````````````````````````

 if the no.of iteration is  fixed, then it is recommended to use 
  for loop 
  
 if the no.of iteration is not fixed, then it is recommended to use
 while loop 
 
  if the no.of iteration is not fixed and you must execute the statement atleast once then we should use do while loop.
  
  
jump statements:
````````````````
Jump statements are one of the types of control statements in Java that directs the flow of execution in a program.


 break 
 continue
 
break statement:
````````````````
it is encountered inside a loop, 
the loop is immediately terminated and the program control resumes at the next statement following the loop.


break statement is used to break loop or switch statement.


it breaks the current flow of the program at specified condition.

in case of inner loop, it breaks only inner loop.


we can use java break statement in all types of loops such as

 -for loop,
 -while loop 
 -do while loop
 
 syntax:
 
      jump-statement;
	  break;
	  
	  
example:
````````

public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=10;i++)
		{
			if(i==5) {
				//breaking the loop
				break;
			}
			System.out.println(i);
		}
		
	
	}

}


 break statement with inner loop:
 
 it breaks inner loop only if you use break statement inside 
 the inner loop.
 
 
example:
`````````

public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=3;i++)
		{
			//inner loop
			for(int j=1;j<=3;j++)
			{
				if(i==2&&j==2)
				{
					break;
				}
				System.out.println(i + " " +j);
			}
			
		}
		
	
	}

}



3 assignments:

use break statement inside labelled for loop?

use break statement inside while loop?

use break statement inside do-while loop?


continue statement:
````````````````````
it is used in loop control structure when you need to jump 
to the next iteration of the loop immediately.

it can be used with all types of loops such as for,while and dowhile 



purpose: it is used to continue the loop.

note:

it continues the current flow of the program and skips the remaining 
code at the specified condition .


   for(int i=1;i<=10;i++)
   { 
      if(i==5){
	  continue;
	  }
	  sysout(i)
   }
1
2
3
4
6
7
8
9
10

in case of an inner loop, it continues the inner loop only.


syntax:

     jump-statement;
	 continue;
	 
example:
````````
`
public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=10;i++)
		{
			if(i==5)
			{
				continue;
			}
			System.out.println(i);
			
		}
		
	
	}

}

example of continue statement with inner for loop:
`````````````````````````````````````````````````````

public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=3;i++)
		{
			//inner loop
			for(int j=1;j<=3;j++)
			{
				if(i==2&&j==2) {
					continue;
				}
				System.out.println(i + " " + j);
			}
			
		}
		
	
	}

}

assignment:
```````````
use continue statement in labelled for loop?
use continue statement in while loop?
use continue staetment in do while loop?  
  
  
  
  
  
  
String class api in java:
``````````````````````````
String is a predefined class available in java.lang package.

purpose: to store the series of characters.


in how many ways we can create the String object 

 -> two ways
 
 1.using String literal
 2.using new keyword
 
 String s1 = "Rama";(it gets stored inside scp memory area which is the part of 
 heap memory area which is the part of jvm which is the part of ram)
 
 
 String s2 = new String("Rama");
 (it gets stored inside heap memory area )
 
 
 note:
 `````
  scp memory area will not allow duplicates
  
  where as heap memory always creates new object irrespective
  of whether it is same or different.
  
  
 
String s1 = new String("rama");
String s2 = new String("rama");

 

String class object is immutable in nature.


unmodifiable 


->once we create any String object, on top of existing String object 
we could not perform any manipulations/modifications 

how to compare the String:
``````````````````````````
 ->by using == operator(Reference comparision operator)
 ->by using equals() or equalsIgnoreCase()
 ->by using compareTo() or compareTOIgnoreCase()
     -compareTo() compares Strings based on lexigraphical comparision.
	 -based on unicode values.
	 
	 
example:
````````
//program on string comparisions -different ways 

public class Test5 {
	
	public static void main(String[] args) {
		
		//string literal approach -it won't allow duplicates
		String s1 = "rama";
		String s2 = "rama";
		String s5 = "Rama";

		//to find out unicode value of character based on the index
		System.out.println(s1.codePointAt(0));
		System.out.println(s5.codePointAt(0));
		
		
		System.out.println(s1==s2);//true
		System.out.println(s1.equals(s2));//true
		System.out.println(s1.equals(s5));//false
		System.out.println(s1.equalsIgnoreCase(s5));//true
		System.out.println(s1.compareTo(s2));//0
		System.out.println(s1.compareTo(s5));//32
		System.out.println(s5.compareTo(s1));//-32
		System.out.println(s1.compareToIgnoreCase(s5));//0
		
		//using new keyword -it creates everytime as a new object
		String s3 = new String("hyd");
		String s4 = new String("hyd");
		
		System.out.println(s3==s4);//false
		System.out.println(s3.equals(s4));//true
		
	}

}

 
checking immutability vs mutablity using String,StringBuffer and StringBuilder:


public class Test6 {

	public static void main(String[] args) {
		
		//immutable object
	 String s1 = "Rama";
	 s1.concat("hyd");
	 System.out.println(s1);//Rama
	   //mutable object
	 StringBuffer s2 = new StringBuffer("Rama");
	 s2.append("hyd");
	 System.out.println(s2);//Ramahyd
	  //mutable object
	 StringBuilder s3 = new StringBuilder("Rama");
	 s3.append("hyd");
	 System.out.println(s3);//Ramahyd
	 
	 
	 
	}
}


note:
using StringBuffer & StringBuilder we can create mutable Strings but 
differnce is StringBuffer methods are synchrnozed(thread safe) methods where as
StringBuilder methods are non-synchrnized(not thread safe) methods.

example on frequently used methods of String class:
````````````````````````````````````````````````````

public class Test6 {

	public static void main(String[] args) {
		
		String s1 = new String("Rama");
		String s3= new String("Rama");
		String s4 = new String("Rama,hyd,software,hardware");	
		String s2 = "  banga  lore   ";
		int value=40;
		String s5 = String.valueOf(value);
		
		String str = new String("welcome to java sessions");
	
		System.out.println("length of the stirng: " + s1.length());
		
		System.out.println("character at 0th position: " + s1.charAt(0));//R
		
		System.out.println(s1.concat("hyd"));//Ramahyd
		
		System.out.println(s1.contains("R"));//true
		System.out.println(s1.contains("j"));//false
		
		System.out.println(s1.endsWith("j"));
		System.out.println(s2.indent(2));//  banga  lore
		System.out.println(s2.indent(-2));//banga  lore
		System.out.println(s2.indent(0));//  banga  lore	
		System.out.println(s1.intern()==s3.intern());//true
		System.out.println(s1.substring(1));//ama
		System.out.println(s1.substring(0, 3));//Ram
		String[] split = s4.split(",");
		for(String s:split)
		{
			System.out.println(s);
		}
		
		System.out.println(s5+10);
		System.out.println(s2.length());
        System.out.println(s2.strip().length());
        
        System.out.println(str.matches("welcome(.*)"));
        System.out.println(str.matches("tutorials"));
 
	}
}

	
	
	
	
  
  
type casting in java:
`````````````````````
in java, type casting is a method or process that converts one datatype
into another data type in both ways manually and automatically.


The automatic conversion is done by the compiler and manual conversion 
performed by the programmer.


double -> float -> long -> int ->short ->byte

converting a value from one datat type to another data type is known 
as type casting.


there are two types of type casting:

 -widening type casting
 -narrowing type casting
 
 converting a lower data type into a higher one is called 
 widening type casting.
 
 it is also known as implicit conversion or casting down.
 
 it is done automatically.
 
 It is safe because there is no chance to lose the data.
 
 it takes place  when
  
  -both data types must be compatible with each other.
  -the target type must be larger than the source type.
  


example:
`````````

public class Test4 {

	
	public static void main(String[] args) {
		
		int x = 5;
		
		long y = x;
		
		float z = y;
		
		System.out.println("before conversion , int value:" +x);
		System.out.println("after conversion, long value:" +y);
		System.out.println("after conversion,float value: " +z);
		
		
	}
}


narrowing type casting:
```````````````````````
converting a higher data type into a lower one is called
narrowing type casting.

it is known as explicit conversion or casting up.

it is done manually by the programmer.

double -> float -> long -> int ->short ->byte


example:
`````````

public class Test4 {

	
	public static void main(String[] args) {
		
		double d = 323.66;
		
		//converting double data type into long data type
		
		 long l = (long)d;
		
		 //converting long data type into int data type
		 
		 int i =(int)l;
		 
		System.out.println("before conversion :" +d);
		System.out.println("after conversion, long value:" +l);
		System.out.println("after conversion,int value: " +i);
		
		
	}
} 
  
  
  
 java is object oriented programming language

 -> since it follows omg derived principles
 
 inheritance
 polymorphism
 abstraction
 encapsulation
 
class & object


inheritance:
`````````````
  it is the process of taking the properties from one class to another 
  class.
  
  the class which is giving the properties is known as base/super/parent 
  class.
  
  the class which is taking the properties is known as sub/derived/child
  class.
  
  note:
  `````
  using extends keyword we can achieve the concept of inheritance.
  in the context of child class only we have to use extends keyword.
  
  types of inheritances:
  
   simple/single inheritance
   multilevel inheritance
    multiple inheritance
   hierarchical inheritance
   hybrid inheritance
   
   
   E
   
   D
  
  A B C
  
   
  
 note:

 using extends keyword we are able to derive single class from single class 
not from multiple classes or more than one class.

 
->reusability


note:
````
if we create the child class object, memory locations will be created for 
both parent class properties and child class properties where as 
if we create the object for parent class object, only we are able to access
parent class properties.


is-a relation 
``````````````
whenever one class inherits another class,it is called as 
an IS-A relationship.

HAS-A relation:
`````````````````
wheneve an instance of one class is used in another class, it is called
HAS-A relationship.


Parent.java:
````````````
//parent class cum busines logic class
public class Parent {
	
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	public void sub(int x, int y)
	
	{
		System.out.println("substraction is: " + (x-y));
	}

}


Test7.java(execution logic class):
````````````````````````````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		
		Child obj = new Child();
		obj.sum(2, 3);
		obj.sub(4, 3);
		
	}
} 
  
  
java is object oriented programming language

 -> since it follows omg derived principles
 
 inheritance
 polymorphism
 abstraction
 encapsulation
 
class & object


inheritance:
`````````````
  it is the process of taking the properties from one class to another 
  class.
  
  the class which is giving the properties is known as base/super/parent 
  class.
  
  the class which is taking the properties is known as sub/derived/child
  class.
  
  note:
  `````
  using extends keyword we can achieve the concept of inheritance.
  in the context of child class only we have to use extends keyword.
  
  types of inheritances:
  
   simple/single inheritance
   multilevel inheritance
    multiple inheritance
   hierarchical inheritance
   hybrid inheritance
   
   
   E
   
   D
  
  A B C
  
   
  
 note:

 using extends keyword we are able to derive single class from single class 
not from multiple classes or more than one class.

 
->reusability


note:
````
if we create the child class object, memory locations will be created for 
both parent class properties and child class properties where as 
if we create the object for parent class object, only we are able to access
parent class properties.


is-a relation 
``````````````
whenever one class inherits another class,it is called as 
an IS-A relationship.

HAS-A relation:
`````````````````
wheneve an instance of one class is used in another class, it is called
HAS-A relationship.


Parent.java:
````````````
//parent class cum busines logic class
public class Parent {
	
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	public void sub(int x, int y)
	
	{
		System.out.println("substraction is: " + (x-y));
	}

}


Test7.java(execution logic class):
````````````````````````````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		
		Child obj = new Child();
		obj.sum(2, 3);
		obj.sub(4, 3);
		
	}
}

  
 note: constructor should not be inherited.

 
super:
``````
super is a java reserved keyword.
it is always refering immediate parent class properties.

  
  super at variable level
  super at method level
  super at constructor level.
  
  
example:
````````
//parent class cum busines logic class
public class Parent {
	
	int x=100;
	
	
	
}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	int x=200;

	public Child()
	{
		System.out.println(x);
		System.out.println(super.x);
	}

}

Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}
 
  
note:
`````
writing the super() is optional for to invoke the parent class default 
constructor

note:

writing the super(..) is mandatory to invoke parent class parameterized 
constructor when there is no default constructor.


Parent.java:
````````````
//parent class cum business logic class
public class Parent {

	public Parent(int x, int y)
	{
		System.out.println("iam from parameterized constructor-parent");
	}

	
	
}

Child.java:
```````````
//child class cum business logic class
public class Child extends Parent {

	
	public Child() {
		//invoke parent class parameterized constructor
		super(2,3);
		System.out.println("iam from default constructor-child class");
		
	}

}


Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}

  
note:
`````
for every constructor super()is added automaticlly by the java compiler which 
internally invokes parent class default constructor.

 
assignment: write a program which describes super at method level.



note:
`````
multiple inheritance is not possible through the concept of classe(s) , because 
of we will get ambiguity issue if two parent classes are maintaining same 
properties.

this problem we can achieve by using interface concept.


 class Object{
 }

 class A extends Object
 {
 }
 class B extends A
 {
 }
 class C extends B
 {
 }  
  
  
encapsulation:
``````````````

encapsulation = datahiding + abstraction

encapsulated class:

 class is the best example for an encapsulation.
 
 by declaring datamembers as private 
 and by defnining public setters and getter methods(s).
 
 
Student.java:
``````````````

public class Student {

	//data hiding
	private int stid;
	private String stname;
	
	//abstraction 
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	
	public String toString()
	{
		return stid + " " +stname;
	}
	
	
	
}
Test10.java:
````````````

public class Test10 {
	
	public static void main(String[] args) {
		Student student = new Student();
		
		student.setStid(100);
		student.setStname("Rama");
		
		System.out.println("student id: " + student.getStid());
		System.out.println("student name: " + student.getStname());
		
	}

}
  
  
note:
`````
we can achieve the method overloading using object reference 
variable. 


method overriding:
``````````````````
-method name is same
-but logic is different from parent class to child class.

note:
to achieve method overriding minimum we require 
two classe(s) with parent-child realtion.


why should we go for method overriding?
```````````````````````````````````````
we have already parent class method has some logic
if we don't require or if we want to provide some new logic 
then we can go for method overriding.

Object 
  -toString()
  -className@HashCode
  
  
rules for method overriding:

 1.method must have the same name as in the parent class.
 2.method must have the same parameter as in the parent class.
 3.there must be an is-a realtionship.
 4.@Override annotation is recommended while we are overriding.
 
 
Parent.java:
````````````

public class Parent {

	public void sum()
	{
		System.out.println("sum-parent");
	}
	
}

Child.java:
````````````
public class Child extends Parent {

	@Override
	public void sum()
	{
		System.out.println("sum-child");
		//call the super class method
		super.sum();
	}
}

Test7.java:
````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		//Child obj = new Child();
		//Parent obj = new Parent();
		Parent obj=new Child();
		//Child obj =new Parent();
		obj.sum();
		
	}
}


note:
`````
based on the object type which method will be associated with 
which method that will be decided is called as 
runtime polymorphism.

based on the object reference varaible it is not possible.


static methods are not participating in method overriding.


note:
`````
while we are overriding we are allowed to increase the scope of the 
property not possible to decrease the scope of the property.

  private -> default -> protected ->public 

  
private properties are not eligible for method overriding, since private
properties only we are able to access within the class not from outside 
the classe(s).


final methods/properties are not eligile for method overriding, since 
final properties are constants ,  modifications are not possible.  
  
  
  
abstraction:
````````````
  -security
  -enhancements
  -manitability
  -modularity
  
  
  hiding the implementation details and showing only services to the end users.
  
abstraction is also one of the oop principle.

   -abstract classe(s)(partial abstraction)
   -interface
   

abstract class:
````````````````
 ->concrete classes (fully defined classes)
 ->abstract class 
 
 abstract class is a combination of both 
 defined methods 
 and as well as undefined methods
 
 undefined method/abstract method:
   
     public abstract void getRateOfInterest();->method declaration
	 
	 
	 
note:

  if a class contains atleast one abstract method it is highly 
recommended to make corresponding class also as 
abstract class using abstract keyword before the class declaration.



    abstract class Test{
    public abstract void m1();
	public void m2(){}
	
	public Test()
	{
	}
	}

  
 for a single abstract class, how many implementation classe(s) we can define?
 
 as many as you want.

 
  class Test1 extends Test
  {
    public void m1(){}
	
	public Test1()
	{
	  super();
	}
  }


  Test obj = new Test1();
  
  obj.m1();
 

in abstract class, can we define constructor(s)?
yes

Bank.java:
```````````


abstract public class Bank {

	 abstract int getRateOfInterest();
}

SBI.java:
``````````

public class SBI extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 5;
	}

}

CityBank.java:
```````````````

public class CityBank extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 7;
	}

}



TestBank.java:
``````````````

public class TestBank {
public static void main(String[] args) {
	
	Bank b ;
	b=new SBI();
	System.out.println("sbi bank rate of interest is : " + b.getRateOfInterest());
	
	b =new CityBank();
	System.out.println("city bank rate of interest is : " + b.getRateOfInterest());
}
}


example on abstract class with constructor:
````````````````````````````````````````````

abstract public class Bike {
	
	Bike()
	{
		System.out.println("bike is created");
	}

	void changeGear()
	{
		System.out.println("gear changed");
	}
	
	abstract void run();
}


Honda.java:
````````````

public class Honda extends Bike {

	@Override
	void run() {
		
		System.out.println("running safely...");

	}

}

TestAbstraction.java:
`````````````````````
public class TestAbstraction {
public static void main(String[] args) {
	
	
	Bike obj = new Honda();
	obj.run();
	obj.changeGear();
}
}


interface:
``````````

interface
implemetnatin class
execution logic class



interface i1
{
  public abstract void m1();
  public static final int x=100;
}

note:
by default interface methods are public abstract 
and by default interface datamembers are public static final.


 extends: 
 
 using extends keyword we can take the properties from 
 class to class and interface to interface (homogenious)
 
 implements:
 
 using implements keyword we can take the properties from 
 interface to class(heterogenious)
 
 assignment:
 do one program on top of interface
 
interface inheritance and multiple inheritance:
```````````````````````````````````````````````

public interface i1 {
	
	void m1();

}


i2.java:
`````````

public interface i2 extends i1 {
void m2();
}


Test9.java:
```````````

public class Test9 implements i2 {

	@Override
	public void m2() {
		System.out.println("m2 body");

	}

	@Override
	public void m1() {
		System.out.println("m1 body");

	}
	
	public static void main(String[] args) {
     	i2 obj;
		obj = new Test9();
		obj.m1();
		obj.m2();
	
	}

}
  

packages:
``````````
package is a 
   collection of 
    
	   classes,interfaces & sub packages
	   
	   classes
	   interfaces
	   annotations
	   exceptions
	   errors
	   enums
	   
	   

types of packages:
  1.pre-defined packages->sunmicrosystems
  
   ->to perform common operations
   
   jse,jee,jme-
   
   note: all jse packages starts with java.
 
list of predefined jse packages:
`````````````````````````````````
java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io
java.lang
java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql
java.text
java.text.spi
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.zip
 
   
  2.user-defined packages
  
  
advantage:
```````````
->reusability
->avoid naming conflicts

System.out.println();

PrintStream class 

  println()
  print()

out object is available as a static data member inside
System class. 

System.out.print();


note:
by default java.lang package will be imported to 
each and every java program.


except java.lang package releated api,if we really need any other packages 
api's , for sure we have to import those packages into our program. 
otherwise we will get compiletime error.

syntax:

          import <packagename>.<classname>/<interfacename>;
		  import <packagename>.*;
		  
		  

user-defined packages:
````````````````````````
  we can define our own package just to keep our own clases or our 
  own interfaces..
  
  syntax:
  
      package <packagename>;
	  
      class {}
	  
	  interface {}
	  
note:
package statement always must be the first executable statement.

note:
if we didn't keep our classes/interfaces inside a package, by default jvm 
will keep those inside default package

default package name given by sunmicrosystem -> noname


note:

if two classes are belongs to same package, from one class if we want to 
access other class methods 'import' is not required.

Test1.java:
```````````
package p1;
//business logic class
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}


Test2.java:
```````````
package p1;
//execution logic class
public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 3);
		
	}

}

naming convention to create package(s):
``````````````````````````````````````
   <reversedomainofcompanyurl>.<projectname>.<modulename>;
   
   com.wipro.banking.fundtransfer;
   
   com.wipro
     com.wipro.banking
	 com.wipro.fundtransfer
   
Test1.java:
`````````````
package p1;
//business logic class
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}


Test3.java:
```````````
package p2;
import p1.Test1;
public class Test3 {
	
	
	public static void main(String[] args) {
		
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
		
	}

}


note:
`````
by importing main package,we won't get sub packages properties
if we want subpackages properties we need to import subpackage too explicitly.


package p1;
//business logic class
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}


Test2.java:
```````````
package p1.p2;

public class Test2 {
	public void sub(int x, int y)
	{
		System.out.println("substraction is: " + (x-y));
	}

}


Test3.java:
````````````
package p3;
import p1.Test1;
import p1.p2.Test2;
//execution logic class
public class Test3 {

	public static void main(String[] args) {
		
		Test1 obj1  = new Test1();
		Test2 obj2 = new Test2();
		
		obj1.sum(3, 4);
		obj2.sub(4,3);
		
	}
	
}

access modifiers:
 `````````````````
 
 we have 4 access modifiers in java
 
  1.private
  2.default
  3.protected
  4.public
  
purpose:
```````
it controls the visibility of the data 
over the packages.


private access modifier:
`````````````````````````

private properties 

we can access only with in the class in which class you defined. 

we can't access from other classes of same pacakge
we can't access from other package other classes .

Test1.java:
````````````
package p1;

public class Test1 {
	
	//private property
	private void sum(int x, int y)
	{
		System.out.println(x+y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}

}

Test2.java:
```````````
package p1;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		//error: obj.sum(2,3);
	}

}


default access modifier:
````````````````````````
  default is not a keyword like other 
  access modifiers.
  
  if we are not using any access modifier keyword
  it will consider as default property.
  
within the package from any class, we are able to access 
default properties.

shall we try in other package?

from other packages, we are not able to access default properties.

if we try for that, we will get compile time error saying that 
property not visible.

protected access modifier:
```````````````````````````
with in the class -> yes
with in the same package -> yes

other package indepenedent class -> no

other package child class -> yes

Test1.java:
``````````
package p1;

public class Test1 {
	
	//protected property
	protected void sum(int x, int y)
	{
		System.out.println(x+y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}

}

Test2.java:
````````````
package p1;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2,3);
	}

}

Test3.java:
````````````
package p2;

import p1.Test1;
//other package child class
public class Test3 extends Test1 {
	
	public static void main(String[] args) {
		
		Test3 obj = new Test3();
		obj.sum(3, 2);
		
	}

}

public:
````````
there is no restriction for this access modifier
if you define anything as public access modifier 
we can access from anywhere. 

 ->universal access modifier.
 
 
 with in the class -> yes
 with in the same package - yes
 
 other pacakge indepenedent class ->yes
 other package sub class -> yes
 
Test1.java:
```````````
package p1;

public class Test1 {
	
	//public property
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}

}

Test2.java:
````````````
package p1;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2,3);
	}

}

Test3.java:
```````````
package p2;

import p1.Test1;
//other package independent class
public class Test3  {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 2);
		
	}

}


note:

if the method is not available inside child class, then immediately 
java compiler will look for that particular method inside parent class.


Object class is acting as super class in java for every class 
whether it is predefined or userdefined class.

what are the different methods we have inside Object class?

   clone()
   finalize()
   hashCode()
   equals()
   toString()
   getClass()
   wait()(3)
   notify()
   notifyAll()
 

every class in java, is an example of what type of inheritance?

 single/simple inheritance

class Test1 
{
}
 
note:
if you are just displaying any java class object internally it invokes
toString() accordingly we will get the output.


example:
````````
package com.infotech.object;
//example on Object class few methods
public class Test1 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		Test1 obj1 = new Test1();
		
		
		
		//toString()-returns string reprsentation of the Object
		System.out.println(obj.toString());//com.infotech.object.Test1@515f550a
		//ctrl+shift+t
		
		System.out.println(obj);
		
		System.out.println(obj.hashCode());
		System.out.println(obj1.hashCode());
		
		System.out.println(obj.getClass());
		
        System.out.println(obj.equals(obj1));
		
		
		
	}

}

overriding toString() method to get the desired result:

Student.java:
``````````````
package com.infotech.object;

public class Student {

	
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	@Override
	public String toString()
	{
		return stid + " " +stname;
		
	}
	
}

Test2.java:
```````````
package com.infotech.object;

public class Test2 {
	
	public static void main(String[] args) {
		
		Student obj1 = new Student();
		obj1.setStid(100);
		obj1.setStname("khan");
		
		System.out.println(obj1);
		
	}

}

exception handling:
```````````````````
if you make any mistakes in java syntactically , what will happen?

 then java compiler gives error, those errors are what we call 
 compile time errors.
 
 
while we are running / executing the java program, jvm is giving us
some errors those errors are called runtime errors. 
technical name of runtime error is known as exception.

why are we getting the exceptions?

because of logical mistakes.
 
  division of two numbers 
  
    100/20 if you pass valid input - valid output
	
	 100/0 -> error (logical mistake) ->


if you pass any invalid input -> jvm won't process 
->error -> exceptions



when we get the exception what will happen?


->control terminated abnormally

->jvm will give system error messages



 1000 lines 
--
--
-- int x = 100/0;
--
--
--
--
 997 lines of code won't executed
 
java.lang.ArithmeticException 

we have to avoid the above drawbacks for this what we have to 
do as a programmer?


  we need to handle the exceptions.
  
  
how can we handle the exceptions?

 in java, we have 5 java reserved keywords are there
 
  1.try
  2.catch
  3.finally
  
  4.throws
  5.throw


try:
````
try block is used to keep the problematic statements which are causes 
problems at runtime.


syntax:
```````
  try{
     //problematic statement(s)
  }

catch:
`````
catch block is  used to catch the exception and to provide user friendly 
message.


atm machine 
 account =5k 
  withdraw - 6k
  
insufficient funds


syntax:


               catch(exceptionclassnaem <referencevariablename>)
			   {
			     //user friendly message
			   }



whenever we get the exception, control terminated abnormally that's why 
we can't maintain normla flow of the execution, 
to maintain we have to handle the exceptions

java is robust(strong), meaning that in every case means postive case 
or negative case our project should be in a postition to give the support
to the end users otehrwise no one will use our product.

example of exception handling using try and catch along with 
Scanner class:
``````````````````````````````````````````````````````````````
package com.infotech.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter the first number");
		
		int fno = s.nextInt();
		System.out.println("enter the second number");
		int sno = s.nextInt();
		
		int division = fno/sno;
		
		System.out.println("division is : " + division);
		}
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		catch(InputMismatchException im)
		{
			System.out.println("please pass only numeric values");
		}
	
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		
	}

}

finally block:
``````````````
finally block is used to keep closing releated logic like 
closing the file, closign the database connection etc.. 

if you keep that closing related logic, in both valid and invalid case 
the code gets executed . 

so that data leakage issues won't occure if you keep closing related 
logic inside finally block.

note:
while we are handling the exceptions the order must be from 
specific to general not from general to specific because if you mention 
like that code will be unreachable by the java compiler getting compile time error.

example:
````````
package com.infotech.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter the first number");
		
		int fno = s.nextInt();
		System.out.println("enter the second number");
		int sno = s.nextInt();
		
		int division = fno/sno;
		
		System.out.println("division is : " + division);
		}
		catch(ArithmeticException ae)
		{
			System.out.println();
		}
		catch(RuntimeException re)
		{
			System.out.println(re);
		}
		
		
		//RuntimeException re = new ArithmeticExceptioni();
		
		
		finally
		{
			System.out.println("finally block executed always");
		}
	
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		
	}

}


throws:
```````
throws is a java reserved keyword 

purpose: it will give you the instruction or warning to calling function 
to keep the called function under try and catch block.


example:
````````
package com.infotech.exceptions;

//called program
public class Test2 {
	
	//called function
	public void division() throws ArithmeticException
	{
		int z = 100/0;
		System.out.println("division is: " + z);
	}

}

Test3.java:
````````````
package com.infotech.exceptions;
//calling program
public class Test3 {
	
	//calling function 
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("please check division method logic");
		}
		
		System.out.println("rest of the statements executed");
		
	}

}

throw:
```````

using throw keyword, we can throw an exception explictly.


  100/0 
  
     ArithmeticException -> jvm->implicitly

based on our condition, if the condition met, if we want to throw 
any exception explictly then we have to use throw keyword.

syntax:

    throw new <exceptionclassname>();

using throw keyword, we can implmenet our own exceptions 
or customized exception.


   ->ecommerce application 

   ->checking the product based on the product weight

   ->if product weight is < 100 it is valid else < 100 
     throw the InvalidProductException .

note:
every exception in java is a class whether it is predefined exception or 
user defined exception.

	 
	 
	 

Test4.java:
``````````
package com.infotech.exceptions;
//business logic class
public class Test4 {
	
	public void checkProduct(int weight)
	{
		if(weight > 100)
		{
			System.out.println("product is valid");
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ip)
			{
				System.out.println("product weight must be greater than 100");
			}
			
		}
	}

}

InvalidProductException.java:
```````````````````````````````
package com.infotech.exceptions;

//it is an user defined exception class
public class InvalidProductException extends Exception {

}


Test5.java:
```````````
package com.infotech.exceptions;

//execution logic class
public class Test5 {

	
	public static void main(String[] args) {
		
		
		Test4 obj = new Test4();
		
		obj.checkProduct(20);
		
	}
}






FileHandling/iostreams:
```````````````````````

stream : flow of the data in between primary memory to secondary memory 
and viceversa.



  while we are working on top of files, make sure we have to import 
  one predefined package i.e java.io 
  
  
  why files ->to store the data
  
  how can we create the file in java?
  
  using one predefined class File 
  
  
default imported package to every java program is
java.lang 

otherthan this package, if we want to use any other classes/interfaecs
make sure we have to import corresponding package 

example to create the file using File class of java.io package:
````````````````````````````````````````````````````````````````
package com.infotech.files;
import java.io.File;
import java.io.IOException;
public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the file using File class
		
		File f = new File("abc.txt");
		try {
		f.createNewFile();
		}
		catch(IOException io)
		{
			System.out.println(io);
		}
		
		System.out.println(f.exists());
		
	}

}








On top of files, we can perform different operations 

 1.read operation 
 
 2.write operation 
 
 stream ->  it is a flow of data in between primary memory to secondary memory or viceversa.
 
 write opeation: 
 
   meaning that we are trying to insert the data into file.
   
 read operation: 
 
   meaning that we are trying to read the data from the file.
   

in iostreams, we have two types of streams 
are available in java.
 
  1.byte stream 
  2.character stream 
  
 if the data flow in the form byte by byte - bytestream 
 if the data flow in the form of character by character - character stream 

in java, io package we have different classes which belongs to 
byte stream, character stream 


read() -read the data from the file 

 where exactly file is available-inside our hard disk/secondary memory
 
 primary memory 
 
 from secondary memory to primary memory.
 
write() -> data flow is happening from primary memory to secondary memory.

when should we use bytestream related classes?

If we have a file that contains binary data, then it will be appropriate to use Byte stream.

when should we use character stream related clases?

Character stream is useful when we want to process text files







 
character stream related classes:
`````````````````````````````````

   java.io package 
   
   write operation 
   
   while we are peforming write operation data flow is happening 
   from primary memory to secondary memory.
   
   
FileWriter
BufferedWriter
PrintWriter

  -majorly we are using three classes which are of character stream type 
  classes for the purpose of writing the data into the file.
  
  
  
FileWriter:
````````````
FileWriter is a character stream related class, which is used to write 
the character data into the file.

example:
````````
package com.infotech.files;

import java.io.FileWriter;
import java.io.IOException;

public class Test2 {
	
	public static void main(String[] args) throws IOException {
		//write operation 
		//create the object of FileWriter 
		FileWriter fw = new FileWriter("abc.txt");
		
		//write the data
		
		
		
		fw.write("abc\n");
		
		fw.write("rama\n");
		
		fw.write(100);
		
		fw.flush();
		
		
		
		System.out.println("write operation successfully done");
		
		
		
	}

}

drawbacks:
``````````
1.using this we can't insert the different types of data, even though if we try it gets converted into corresponding unicode character.

2./n we have to use for the line separator and it may or may not work in all operating systems because it got implemented in c language.

that's why we will go from FileWriter to BufferedWriter


BufferedWriter:
```````````````
whiel we are creating the object of BufferedWriter , we have to pass the 
object of Writer class implemenation class object. 

 BufferedWriter bw = new BufferedWriter(Writer w);

example:
````````
package com.infotech.files;

import java.io.BufferedWriter;
import java.io.FileWriter;

public class Test3 {
	
	public static void main(String[] args) throws Exception {
		
		//create the object of FileWriter
		
		FileWriter fw = new FileWriter("abc.txt");
		//create the object of BufferedWriter
		
		BufferedWriter bw =
				new BufferedWriter(fw);
		
		bw.write("abc");
		bw.newLine();
		bw.write("rama");
		bw.newLine();
		bw.write(100);
		
		bw.flush();
		
		System.out.println("write opearation done");
	}

}


drawaback:
we can't write differnt types of data but we can achieve the line separator problme by using a new method newLine() of BufferedWriter class.
which will work in any operating systems because it got implemented in java language.

to avoid the above problem, we have to move from BufferedWriter class 
to PrintWriter class.


PrintWriter:
``````````````
PrintWriter is the class available in java.io package for the purpose 
of writing the character data very effectively.

example:
````````
package com.infotech.files;

import java.io.IOException;
import java.io.PrintWriter;

public class Test4 {
	
	public static void main(String[] args)throws IOException{
		
		
		//create the object of PrintWriter class
		
		PrintWriter pw = new PrintWriter("abc.txt");
		
		pw.println("abc");
		pw.println("Rama");
		pw.println(100);
		pw.println(3.4f);
		pw.println(false);
		pw.print(56.78);
		
		pw.flush();
		
		System.out.println("write operation has done");
		
		
	}

}


example on read and write operation on binary data using bytestream 
related clasess:
``````````````````````````````````````````````````````````````````````

package com.infotech.files;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Test7 {
	
	public static void main(String[] args) {
		try {
			//create the object for FileInputStream for reading the binary data
		FileInputStream fis = new FileInputStream("encapsulation.jpg");
		
		//create the object for FileOutputStream for writing the binary data
		FileOutputStream fos = new FileOutputStream("naveesh.jpg");
		
		
		int x;
		while((x=fis.read())!=-1) {
			
			fos.write(x);
		}
		System.out.println("image created succesfully");
		}
		
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
	}

}








serialization & desererialization 
``````````````````````````````````
serialziation:
``````````````

the process of writing the object data  into network suppored format 
is known as serialization.

because by default network won't support object format data to transfer 
from one machine to another machine.

desserialization:
````````````````

the process of reading the object data from the network supported file 
is known as deserizliation.



   

 ->ObjectInputStream 
     predefined class 
	 java.io 
	 purpose: to read the object data 
	 method: readObject()
	 
 ->ObjectOuputStream 
     predefined class
	 java.io
	 purpose: to write the object data 
	 
	 method: writeObject()
	 
 

Student.java:
```````````````
package com.infotech.files;

import java.io.Serializable;

public class Student implements Serializable{
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public Student(int stid, String stname)
	{
		this.stid=stid;
		this.stname=stname;
		}
	
	public Student()
	{
		
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}

}

example for serialziation:
`````````````````````````````
package com.infotech.files;

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;

//serialization
public class Test8 {
	
	public static void main(String[] args) throws Exception{
		
		
		//create the object for FileOutputStream 
		FileOutputStream fos = new FileOutputStream("ram.txt");
		
		//create the object for ObjectOutputStream 
		
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		
		
		Student st= new Student(100,"ram");
		
		
		oos.writeObject(st);
		
		System.out.println("serialization process has done");
		
		
	}

}

example for desererialization:
`````````````````````````````
package com.infotech.files;

import java.io.FileInputStream;
import java.io.ObjectInputStream;

//deserialization
public class Test9 {

	
	public static void main(String[] args) throws Exception {
		
		//create the object of FileInputStream 
		
		FileInputStream fis = new FileInputStream("ram.txt");
		//create the object of ObjectInputStream 
		
		ObjectInputStream ois = new ObjectInputStream(fis);
		
		
		Object obj = ois.readObject();
		//convert Object type to Student type
		//convert parent type to child type -down casting
		
		
		
		Student stu = (Student)obj;
		
		System.out.println(stu);
		
	
	}
}

 
 
note:
every java class we can't serialize, to make it happen corresponding 
java class must be implementing from Serializable marker interface 
which is available in java.io package otherwise we will get exception 
saying that java.io.NotSerialziable 

 
transient keyword:
```````````````````
transient is a variables modifier used in serialization. At the time of serialization, if we don't want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type

Collection framework:
`````````````````````
collection framework :
````````````````````

int x = 100;
int y = 200;
int z = 300;


 ->1000 values 
 1000 variables 
 
 to store 1000 values declaring 1000 varialbles, 
 is not a good programming practice.
 
 
Array:
  
   using arrays, we can store multiple values in a single variable.
   
   int x[]={100,200,300};
   
   
   int x[] =new Integer[5];
   
 -> the size is fixed in nature, you can't increase or decrease the memory 
    at runtime.
	
 -> using arrays, we can store only homogenious data, we can't store 
    heterogenous data.
	
 -> inside arrays, we don't have any ready made methods,to perform any 
    operation, we have to do manually.

 -> internally arrays are not following standard data structures.

 collection framework:
 ````````````````````
 it is the standardized mechanism of grouping similar type of data 
 and differnt type of data into a single entity. 
 
  ->java.util package
  
 

 
 few interfaces and few implementation clases

                 1 Collection 
   
2.List          3.Queue                 4.Set

                                        5.SortedSet
          
                            


interface SortedSet extends Set extends Collection 
{
}




 

Collection:
```````````

if we want to group similar objects and diffrent objects as a single entity 
then we should go for Collection .

note:
Collection is the root interface for all the remaining interface(s)
there is no direct implementation class for this Collection interface.


add()-to add an object

addAll(Collection)

remove()
removeAll()


List:
`````

  always working based on index
  
List is the predefined interface avaialble in java.util package

-> it allows both homogenious and heterogenous object(s)
-> insertion order is preserved
-> duplicates are allowed
-> null insertion is possible 

note:
 collection object supports only object data.
 
 
 For List interface, sunmicrosystem people provided few implemenation classes
 
 1.ArrayList
 2.LinkedList
 3.Vector
 4.Stack
 
 
 List l = new ArrayList();
 

example:
``````````
package com.jse.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {

	public static void main(String[] args) {
		
		//create the object for List
		
		List l = new ArrayList();
		
		//add the object
		l.add(Integer.valueOf(100));
		l.add(Integer.valueOf(200));
		l.add(new String("rama"));
		l.add(Boolean.valueOf(true));
		l.add(Integer.valueOf(100));
		l.add(null);
		
		System.out.println(l);//[100, 200, rama, true, 100, null]
		 		
		
		l.add(300);
		System.out.println(l);//[100, 200, rama, true, 100, null, 300]
		
		l.add(1, Integer.valueOf(300));
		
		System.out.println(l);//[100, 300, 200, rama, true, 100, null, 300]
	
		System.out.println(l.remove(1));
		
		System.out.println(l);//[100, 200, rama, true, 100, null, 300]
		
		l.remove(Integer.valueOf(100));
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		System.out.println("size of the collection : " + l.size());
		
		System.out.println(l.get(1));//rama
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		List l1 = new ArrayList();
		l1.add(500);
		l1.add(400);
		l1.add(600);
		
		l.addAll(l1);
		
		System.out.println(l);//[200, rama, true, 100, null, 300, 500, 400, 600]
		
		l.removeAll(l1);
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		
		System.out.println(l.contains(200));
		
		System.out.println(l.isEmpty());
		
		l.clear();
		System.out.println(l.isEmpty());
		
		System.out.println(l);//[]
		
		
	}
}

ArrayList hierarchy:
``````````````````````
class ArrayList implements List extends Collection 
{
}




assignment:
do the same program w.r.to LinkedList


Collection 
List
   ArrayList
   LinkedList
   Stack
   Vector
   
   
  



eventhough we are passing primitive data internally it is getting converted into object format.

autoboxing and autounboxing
`````````````````````````````

Autoboxing is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. 

For example, converting an int to an Integer, a double to a Double, and so on. If the conversion goes the other way, this is called unboxing.

java compiler:

autoboxing: primitive type to object type
autounboxing: object type to primitive type

this feature is available from jdk 1.5 version onwards.



difference between ArrayList and LinkedList:

ArrayList internally follows dynamic array algorithm to store the elements 
and if our frequent operation is accessing / retrieval then it is highly 
recommended to use this ArrayList.

   ArrayList implements RandomAccess
   {
   }


LinkedList internally follows doubly linkedlist algorithm where the data 
is getting stored based on the node wise. 
that's why if our frequent operation is insertion/deletion/updation we can go for LinkedList because no shift operations are happend like ArrayList.



Stack
Vector 
do the programs on top of above two classes?


Queue:
```````

Queue is also sub interface of Collection 

->if we want to represent a group of individual objects prior to processing then we should go for Queue and Queue follow First In First Out algorithm.



  
  

  Queue
  
   -ArrayDeque
   -LinkedList
   -PriorityQueue
   
   
boolean offer(Object obj)
Object poll()
Objet remove()
Object peek()-will give you head element->null
Object element()-will give you head element ->exception 

...

in case of ArrayDeque and LinkedList 

  -it allows both homogenious and heterogenous data
  -duplicates are allowed
  -insertion order is preserved
  -null insertion is possible only if implementation class is LinkedList
   in case of ArrayDeque it gives you NullPointerException

in case of PriorityQueue 

  -it allows only homogenious data
  -insertion order is not preserved
  -duplicates are allowed
  -null insertion is not possible if you try for that it gives you 
   NullPointerException 
   
   

example:
````````
package com.jse.cfw;

import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.Queue;

public class Test4 {
	
	public static void main(String[] args) {
		
		Queue obj = new LinkedList();
		
		obj.offer("rama");
		obj.offer("freejava");
		obj.offer("benny");
		obj.offer("shekhar");
		obj.offer("shekhar");
		obj.offer(null);
		
		
		
		
		
		
		System.out.println(obj);
		
		System.out.println(obj.poll());
		
		
		System.out.println("head: " +obj.element());
		
		System.out.println("head:" + obj.peek());
		
		obj.clear();
		
		//System.out.println(obj.element());//NoSuchElementException
		
	    System.out.println(obj.peek());
		
	}

}



`

Set extends Collection 

SortedSet extends Set extends Collection 


Set:
````

Set is the predefined interface available in java.util package


 ->it supports both homogenious and heterogenous data
 ->duplicates are not allowed 
 ->insertion order is not preserved.
 ->null insertion is possible but only for one time.
 
   Set obj = new Set();//invalid
   

->HashSet
->LinkedHashSet


insertion order is preserved in case of LinkedHashSet but it is not 
in the case of HashSet.

example:
```````
package com.jse.cfw;

import java.util.LinkedHashSet;
import java.util.Set;

public class Test5 {
	
	public static void main(String[] args) {
		
		
		Set s = new LinkedHashSet();
		
		s.add("abc");
		s.add(null);
		s.add(123);
		s.add(true);
		s.add(123);
		
		System.out.println(s);
	}

}



if you knew in advance  my collection class allows only particular type 
of data then i can create the collection object by specifying that data type.



using generics concept we are getting two advantages

1.compile time errors we will get rather than runtime errors and these compile time errrors are far better than runtime errors.

2.we no need to perform type casting when you apply generics concept.

  

example:
``````````
package com.jse.cfw;

import java.util.LinkedHashSet;
import java.util.Set;

public class Test5 {
	
	public static void main(String[] args) {
		
		//generics concept
		Set<Integer> s = new LinkedHashSet();
		
	    for(int i=1;i<=10;i++)
	    {
	    	s.add(i);
	    	
	    }
		
	    
	    
		//for each loop
		
		for(Integer o:s) {
			
			
			if(o%2==0)
			{
				System.out.println(o);
			}
			
		}
	}

}




how to add user defined object to any colelction class:
````````````````````````````````````````````````````````
package com.jse.cfw;

import java.util.ArrayList;

public class Test2 {
	
	public static void main(String[] args) {
		
		ArrayList<Student> al = new ArrayList();
		
		
		al.add(new Student(100,"Rama"));
		al.add(new Student(101,"pavan"));
		al.add(new Student(102,"praveen"));
	
		
	     //foreach loop
		for(Student s:al)
		{
			if(s.getStname().startsWith("p"))
			{
				System.out.println(s);
			}
				
		}
		
	}

}




SortedSet:
`````````

->it supports only homogenious data.

->duplicates are not allowed

->the order we can predict (it will sort the data )
  natural sorting technique -> alphabetical order, ascending 
  

->null insertion is not possible (NullPointerException)


SortedSet is the sub interface of Set interface , it is the sub interface 
of Collection 


SortedSet is maintaining some specific new methods 


  first()
  last()
  headSet()
  tailSet()
  subSet()
  
  


for this SortedSet interface 

   ->TreeSet
   
   
 package com.jse.cfw;

import java.util.TreeSet;

public class Test6 {

	public static void main(String[] args) {

		TreeSet<Integer> s = new TreeSet();

		s.add(123);
		s.add(876);
		s.add(98);
		s.add(67);
		s.add(1000);

		/*
		 * s.add("rama"); s.add("praveen"); s.add("harish"); s.add("john");
		 */

		System.out.println(s);
		
		System.out.println(s.first());
		System.out.println(s.last());
		System.out.println(s.headSet(123));
		System.out.println(s.tailSet(123));
		System.out.println(s.subSet(98, 1000));
	}

}
  






how to add user defined objects to the TreeSet:
```````````````````````````````````````````````
package com.jse.cfw;

public class Student implements Comparable<Student> {

	private int stid;
	private String stname;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Student() {

	}

	public Student(int stid, String stname) {
		this.stid = stid;
		this.stname = stname;

	}

	public String toString() {
		return stid + " " + stname;
	}



	

	@Override
	public int compareTo(Student o) {
		
		if(stid>o.getStid())
		{
		{
			return -1;
		}
		else if(stid<o.getStid())
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}



	
}



Test6.java:
````````````
package com.jse.cfw;

import java.util.TreeSet;

public class Test6 {

	public static void main(String[] args) {

		TreeSet<Student> s = new TreeSet();

		Student st1 = new Student(10,"chenna");
		Student st2 = new Student(8,"venkat");
		
		s.add(st1);
		s.add(st2);
		
		System.out.println(s);
		
	}

}

note:
To add any object to TreeSet it should be homogenious and Comparable objects
otherwise we will get java.lang.ClassCastException.




example on overriding equals() and hashCode():
```````````````````````````````````````````````

Student.java:
``````````````
package com.jse.cfw;

public class Student  {

	private int stid;
	private String stname;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Student() {

	}

	public Student(int stid, String stname) {
		this.stid = stid;
		this.stname = stname;

	}

	public String toString() {
		return stid + " " + stname;
	}


	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + stid;
		result = prime * result + ((stname == null) ? 0 : stname.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (stid != other.stid)
			return false;
		if (stname == null) {
			if (other.stname != null)
				return false;
		} else if (!stname.equals(other.stname))
			return false;
		return true;
	}
	
	
}

Test6.java:
`````````
package com.jse.cfw;

import java.util.HashSet;

public class Test6 {

	public static void main(String[] args) {

		HashSet<Student> s = new HashSet();

		Student st1 = new Student(10,"chenna");
		Student st2 = new Student(10,"chenna");
		
		s.add(st1);
		s.add(st2);
		
		System.out.println(s);
		
	}

}




cursors in java
`````````````````
cursor -> it is pointing to some element 


  Enumeration-outdated 
  
     on top of legacy classes 
	  
	   Hashtable
	   Vecotr
	   Stack...
	   
	   
  Iterator
  ListIterator
  
  

example on Iterator:
```````````````````
package com.jse.cfw;

import java.util.HashSet;
import java.util.Iterator;

public class Test7 {
	
	public static void main(String[] args) {
		
		HashSet<Integer> hs = new HashSet<Integer>();
		
		for(int i=1;i<=10;i++)
		{
			hs.add(i);
			
		}
		System.out.println(hs);
		
		//foreach method
		
		/*
		 * for(Integer i: hs) { System.out.println(i); }
		 */
		
		Iterator<Integer> iterator = hs.iterator();
		
		while(iterator.hasNext())
		{
			System.out.println(iterator.next());
		}
		
		iterator.remove();
		System.out.println("=====================");
		for(Integer i:hs)
		{
			System.out.println(i);
		}
		
		
		
		
	}

}
//hasNext() - to check whether collection object contains elements or not?
//next() -> to read the current element
//remove() -> to remove the elements



note: 
Iterator is uni-directonal cursor
using this we are allowed to retrieve the elements only in forward 
direction.

universal cursor.



ListIterator:
``````````````
ListIterator is the powerfull cursor in entire cfw.

 -> we are allowed to retreive the elements in both forward direction 
    and as well as backward direction.

 ->using this we can modify,add, remove the data.
	
	
drawback: we can apply this ListIterator interface only on top of list related implemenataion classes. 
 
 
example on ListIterator:
```````````````````````
package com.jse.cfw;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.ListIterator;

public class Test7 {

	public static void main(String[] args) {

		ArrayList<Integer> al = new ArrayList<Integer>();

		for (int i = 1; i <= 10; i++) {
			al.add(i);

		}

		System.out.println(al);
		
		ListIterator<Integer> ltr = al.listIterator();
		System.out.println("retrieveing the elements in forward direction");
		while(ltr.hasNext())
		{
			System.out.println(ltr.next());
		}
		
		ltr.add(11);
		
		System.out.println("retreiving the elements in backward direction");
		while(ltr.hasPrevious())
		{
			System.out.println(ltr.previous());
		}
		
		ltr.set(100);
		
		System.out.println(al);

	}

}
//hasNext() - to check whether collection object contains next elements or not?
//next() -> to read the current element
//remove() -> to remove the elements
//hasPrevious()-to check whether previous elements are there or not?
//previous()- to retrieve the previous element


example on Enumeration interface:
``````````````````````````````````
package com.jse.cfw;

import java.util.Enumeration;
import java.util.ListIterator;
import java.util.Vector;

public class Test7 {

	public static void main(String[] args) {

		Vector<Integer> v = new Vector<Integer>();

		for (int i = 1; i <= 10; i++) {
			v.addElement(i);

		}

		Enumeration<Integer> enr = v.elements();
		
		while(enr.hasMoreElements())
		{
			System.out.println(enr.nextElement());
		}
		
	}

}
//hasNext() - to check whether collection object contains elements or not?
//next() -> to read the current element
//remove() -> to remove the elements
//hasPrevious()-to check whether previous elements are there or not?
//previous()- to retrieve the previous element

  
Comparator:
``````````
Comparator interface available inside java.util pacakge

 inside this interface we do have one method
 
   compare(T1,T2);
   
	 
Comparator is meant for getting the data in our own order / custom order












(key,value) pair

Map

   -
SortedMap


A Map doesn't allow duplicate keys, but you can have duplicate values.

A Map can't be traversed

keySet()
entrySet()


HashMap: HashMap is the implementation class of Map, but it doesn't maintain any order.
		 
LinkedHashMap: it is also the implemenataion class of Map, it inherits HashMap class. it maintains insertion order.


TreeMap:
 TreeMap is the implementation class of SortedMap, it maintains ascending order
 
  put(-,-) -> insert any entry in to the map 
   
   entry ->(key,value)
   
   
  putAll(Map m) -> it is used to insert the specicied map into the existing map.
  
  

interface Map
{
  interface Entry
  {
  }
  
}
Map.Entry:
``````````
Entry is the inner interface of Map. so we will be accessed it by Map.Entry name.

it returns a collection view of the map.


   getKey() 
   getValue()
   

example on HashMap:
```````````````````
1.HashMap doesn't allow duplicate key objects but it allows duplicate value objects
2.it allows null values for both key objects and as well as value objects.
3.insertion order is not preserved.

example:
````````
package com.jse.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		Map m = new HashMap();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		m.put(null, null);
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		Set set =m.entrySet();
		
		Iterator itr = set.iterator();
		
		while(itr.hasNext())
		{
			Map.Entry entry = (Map.Entry)itr.next();
			System.out.println(entry.getKey() + " " + entry.getValue());
					
					
		}
		
	}

}

with generics syntax :
``````````````````````
package com.jse.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		Map<Integer,String> m = new HashMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		m.put(null, null);
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		Set<Entry<Integer, String>> set = m.entrySet();
		
		Iterator<Entry<Integer, String>> itr = set.iterator();
		
		while(itr.hasNext())
		{
	
	       Entry<Integer, String> entry = itr.next();
			System.out.println(entry.getKey() + " " + entry.getValue());
					
					
		}
		
	}

}


using for each loop traversing map elements:
````````````````````````````````````````````
package com.jse.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		Map<Integer,String> m = new HashMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		m.put(null, null);
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		for(Map.Entry<Integer,String> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	}

}

LinkedHashMap vs HashMap

all the properties of HashMap are applicable to LinkedHashMap except LinkedHashMap follows insertion order.


SortedMap:
``````````
SortedMap is the sub interface of Map interface 

 TreeMap is the implementtaion class
 
 
1.TreeMap doesn't allows null keys or null values if you try to add we will get runtime exception saying that java.lang.NullPointerException
  
2.duplicate keys are not possible where as duplicate values are possible

3.we will get the data in ascending order based on the key objects.

example on top of TreeMap:
``````````````````````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Integer,String> m = new TreeMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		for(Map.Entry<Integer,String> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	}

}


example:
````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Integer,String> m = new TreeMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		for(Map.Entry<Integer,String> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
		System.out.println("===========================");
		
		System.out.println(m.firstKey());
		System.out.println(m.lastKey());
		System.out.println(m.headMap(100));//{45=john, 67=charvi}
		
		System.out.println(m.tailMap(100));//{100=rama, 101=rama, 200=amith}
		System.out.println(m.subMap(45, 101));//{45=john, 67=charvi, 100=rama}
		
		
	}

}


adding user defined object as a value object to the TreeMap:
```````````````````````````````````````````````````````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Integer,Book> m = new TreeMap<Integer,Book>();
		
		//create Book Object
		
		Book b1 = new Book(1,"java");
		Book b2 = new Book(2,"angular");
		Book b3 = new Book(3,"spring");
		
		//adding elements to Map
		
		
		
		m.put(400,b1);
		m.put(101, b2);
		m.put(300, b3);
		
		
		for(Map.Entry<Integer,Book> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	
	}

}



sorting the data in our customized order:
``````````````````````````````````````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Book,Integer> m = new TreeMap<Book,Integer>(new BookNameComparator());
		
		//create Book Object
		
		Book b1 = new Book(1,"java");
		Book b2 = new Book(2,"angular");
		Book b3 = new Book(3,"spring");
		
		//adding elements to Map
	
		m.put(b1,400);
		m.put(b2,101);
		m.put(b3,300);
		
		for(Map.Entry<Book,Integer> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	
	}

}


note:
````
this sorting happens based on the key object only not based on the value object
that is the reason your user defined object also must be the key object.

MyCompartor.java:
`````````````````
package com.jse.cfw;

import java.util.Comparator;

public class MyComparator implements Comparator<Integer> {

	@Override
	public int compare(Integer o1, Integer  o2) {
		
		return -o1.compareTo(o2);
	}

}

BookNameComparator.java:
````````````````````````
package com.jse.cfw;

import java.util.Comparator;

public class BookNameComparator implements Comparator<Book> {

	@Override
	public int compare(Book o1, Book o2) {
		return -o1.getBookName().compareTo(o2.getBookName());
	}

}

Book.java:
```````````
package com.jse.cfw;

public class Book {
	
	private int bookId;
	private String bookName;
	public int getBookId() {
		return bookId;
	}
	public void setBookId(int bookId) {
		this.bookId = bookId;
	}
	public String getBookName() {
		return bookName;
	}
	public void setBookName(String bookName) {
		this.bookName = bookName;
	}
	public Book(int bookId, String bookName) {
		super();
		this.bookId = bookId;
		this.bookName = bookName;
	}
	
	public Book()
	{
		
	}
	@Override
	public String toString() {
		return bookId + " " + bookName;
	}
	
	

}


assignment:
````````````
refer about Hashtable and do one program


  
   

 









database:
`````````

relational database management system

  products
  
  
  mysql
  oracle
  ingress
  sybase
  redhat.etc..
  
  
try to install mysql software in your machine

  https://dev.mysql.com/downloads/installer/


basic queries in mysql:
`````````````````````````
create table student(stid integer, stname varchar(20));

insert into student values(100,'rama');

select * from student;

SET SQL_SAFE_UPDATES = 0;
update  student set stname='sitha' where stid=200;

delete from student;

  download mysql
  install 
  mysqlworkbench
  root -root
  

jdbc:
`````
like how we perform db operations from db environment 
we can perform same db operations from java environment

  java to database connectivity.
  
  
we have to follow some steps

1.load the driver class 

in db, we do have 4 types of driver clases are there

 1.type 1,2,3,& 4
 
2.we need to get the connection from the db.

type4 mysql driver url: 


    Connection con =  DriverManager.getConnection("jdbc:mysql://localhost:3306/sys","root","root");


3.create the object for Statement interface

    Statement st = con.createStatment();
	

4.process the quereies

    int x = st.executeUpdate("insert into student values(101,'radha')");
 
5.close the connection 

     con.close(); 

type 4 driver -> platform independent driver - > java language
mysql db type 4 driver 

   ->com.mysql.cj.jdbc.Driver


  Class.forName("com.mysql.cj.jdbc.Driver");
  
   jdbc - specification /it contains only interfaces and these are 
   given by sunmicrosystem 
   
    jdbc related classes/interfaces -java.sql 
	
	but the implementation classes are provided by different 
	different db vendors.
	
	in the form of jar files
	for example
	
	oracle -> ojdbc6.jar -> it contains implementation classes 
	of jdbc interfaces
	
	mysql -> mysql connector.jar -> it contains implemenataion classes 
	of jdbc interfaces.
	
	https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.30/
	
	
	
  
oracle type 4 driver ->  oracle.jdbc.driver.OracleDriver


example 
````````
package com.infotech.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) throws Exception {
		
		
		//load the driver class
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		System.out.println("driver class is loaded");
		
		//obtain the connection 
		Connection con = DriverManager.
		getConnection("jdbc:mysql://localhost:3306/sys", 
				"root", "root");
		
		System.out.println("i got the connection ");
		
		//create the object for Staetment for sending sql queries to db
		
		Statement st = con.createStatement();
		
		//process the insert query
		
		// int x = st.executeUpdate("insert into student values(101,'radha')");
		
		//int x = st.executeUpdate("update student set stname='rama' where stid=100");;
		
		int x = st.executeUpdate("delete from student where stid=101");
		
		System.out.println(x + "row(s) deleted");
		
		//close the connection 
		st.close();
		con.close();
	}

}


how to add the mysql connector.jar file to our project:

 right click on project 
 |
 click on build path 
 |
 click on configure buildpath
 |
 click on libraries
 |
 select the classpath 
 |
 click on add external jars 
 |
 select the jar 
 |
 click on apply 
 
 

example program on how to process select queries:
```````````````````````````````````````````````````

package com.infotech.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Test2 {
	
	public static void main(String[] args) throws Exception{
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/sys", "root", "root");

		Statement st = con.createStatement();
		
		ResultSet rs = st.executeQuery("select * from student");
		
		while(rs.next())
		{
			System.out.println(rs.getInt(1) + " " + rs.getString(2));
		}
		
		con.close();
		
		
	}

}

queries are of two types

  1.static query
  
      -data is constant 
	  -Statement 
	  
	  
  2.dynamic query(pre-compiled query)
  
     -data is dynamic at runtime we have to pass the data 
	 
	 -PreparedStatement 
	 
	 
  

  insert into student values(100,'rama');-static query
  
  
example on to process dynamic queries using PreparedStatement:
````````````````````````````````````````````````````````````````
package com.infotech.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.util.Scanner;

public class Test3 {
	
	public static void main(String[] args) throws Exception {
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/sys", "root", 
				"root");
		
		
		//create the object of PreparedStatement
		
		PreparedStatement ps = con.prepareStatement("insert into student values(?,?)");
		
		Scanner s = new Scanner(System.in);
		System.out.println("enter student id ");
		int x = s.nextInt();
		
		System.out.println("enter student name");
		
		String y = s.next();
		
		ps.setInt(1, x);
		ps.setString(2, y);
		
		int i = ps.executeUpdate();
		
		System.out.println(i + "row(s) inserted");
		
		//close the connection 
		con.close();
		
	}

}


q) Statement vs PrepareStatement

Statement is for processing static queries where as PreparedStatement is 
for processing dynamic queries.


batch processing:
``````````````````

batch:

it is a group of nonselect queries and we can send these queries as a batch or 
group from java to db for processing 

so that in between java environment and db environment we can reduce to
and fro calls. 

because of this performance may increased.

to group  the queries as a batch, we have to use following method.

            addBatch()
			
to process this batch we have to use following method.

           

example on batchprocessing:
````````````````````````````
package com.infotech.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test4 {
	
	public static void main(String[] args) throws Exception {
		
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/sys","root","root");
		
		Statement st = con.createStatement();
		
		st.addBatch("insert into student values(100,'rama')");
		st.addBatch("update student set stname='hanuman' where stid=102");
	
		int x[] = st.executeBatch();
		
		System.out.println(x[0] + "rows inserted");
		System.out.println(x[1] + "rows updated");
		
		
		
	}

}

		   
			
ResultSetMetaData:

 it is one of the predefined interface available in java.sql package 
for the purpose of fetching the meta data of the table or any database 
object.

 to create the object for ResultSetMetaData object, first we have to create the object for ResultSet on top of this object, if we invoke 
getMetaData()which gives you ResultSetMetaData object. 

 once we get the ResultSetMetaData object, we have some predefined methods are there using those we can get the required meta information 
based on the requirement.


example:
`````````
package com.infotech.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;

public class Test5 {
	
	
	public static void main(String[] args) {
		try {
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/sys","root","root");
		
		Statement st =con.createStatement();
		
		ResultSet rs = st.executeQuery("select * from student");
		
		ResultSetMetaData rsmd = rs.getMetaData();
		
		
		for(int x=1;x<=rsmd.getColumnCount();x++)
		{
			System.out.println(rsmd.getColumnName(x) + " " + rsmd.getColumnTypeName(x) + " " + rsmd.getPrecision(x));
		}
		
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
	}

}





Transaction Management:
`````````````````````
transaction 
 
 - do everything or do nothing 
 
 i am transfering the funds from my account to 
 my friend account 
 
 debited from my account 
 credited to your friend account
 

example on transaction management:
```````````````````````````````````
package com.infotech.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test6 {
	
	public static void main(String[] args) throws Exception  {
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/SYS","root","root");
		con.setAutoCommit(false);
		
		Statement st = con.createStatement();
		
		int x=  st.executeUpdate("update rama set bal=bal-10000 where acno=1000");
		int y = st.executeUpdate("update sitha set bal=bal+10000 where acno=1001");
        
		 if(x==1 && y==1)
		 {
			 con.commit();
			 System.out.println("funds transferred succesffully");
		 }
			 
		 else
		 {
			 con.rollback();
			 System.out.println("please check your account number");
		 }
		
		
		
	}

}


mysql table script:
`````````````````````
create table rama(acno integer, accname varchar(20), bal decimal);
create table sitha(acno integer,accname varchar(20),bal decimal);
insert into rama values(1000,'rama',80000);
insert into sitha values(1001,'sitha',1000);
select * From rama;
select * from sitha;

 
 jdbc: 
  nonselect queries
  select queries
  Statement vs PreparedStaement
  BatchProcessing
  ResultSetMetaData
  TransactionManagement
    
  
  
  
  
  
